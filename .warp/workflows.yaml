workflows:
  - name: deploy-auto-branch
    description: Aktueller Branch ‚Üí PR vs BASE ‚Üí Diff zeigen ‚Üí CodeRabbit anwenden (iterativ) ‚Üí Vercel Preview
    command: |
      set -euo pipefail

      BASE="{{base}}"
      [ -z "${BASE}" ] && BASE="develop"
      BOT="${BOT:-coderabbitai[bot]}"
      POLL_SECONDS="${POLL_SECONDS:-15}"
      TIMEOUT_SECONDS="${TIMEOUT_SECONDS:-420}"

      # Checks
      for bin in gh vercel node jq git; do
        command -v "$bin" >/dev/null || { echo "‚ùå '$bin' fehlt"; exit 1; }
      done

      CURR_BRANCH=$(git rev-parse --abbrev-ref HEAD)
      if [ "$CURR_BRANCH" = "$BASE" ]; then
        echo "‚ùå Du bist auf dem BASE-Branch '$BASE'. Bitte auf einem Feature-Branch arbeiten."
        exit 1
      fi

      # 0) Upstream holen & Delta sichtbar machen
      echo "üîÑ Fetching origin/$BASE..."
      git fetch origin "$BASE" || true
      echo
      echo "=== üìä √Ñnderungen gegen√ºber origin/$BASE (Dateien) ==="
      git --no-pager diff --name-status "origin/$BASE...HEAD" || true
      echo
      echo "=== üìà Diff-Statistik ==="
      git --no-pager diff --stat "origin/$BASE...HEAD" || true
      echo
      echo "=== üìù Commits gegen√ºber origin/$BASE ==="
      git --no-pager log --oneline --decorate --graph "origin/$BASE..HEAD" | head -20 || true
      echo

      # 1) Commit & Push aktueller Branch
      echo "üîß Committing und pushing current branch..."
      git add -A
      if ! git diff --cached --quiet; then
        git commit -m "chore: warp deploy batch $(date +%H:%M)"
      fi
      git push -u origin "$CURR_BRANCH"

      # 2) PR anlegen/holen
      echo "üîó Creating/updating PR..."
      if gh pr view "$CURR_BRANCH" >/dev/null 2>&1; then
        echo "‚ÑπÔ∏è PR existiert bereits."
      else
        gh pr create --title "üöÄ Auto PR: $CURR_BRANCH" --body "Automatisiert via Warp deploy-auto-branch workflow" --base "$BASE" --head "$CURR_BRANCH" --fill
      fi

      PR=$(gh pr view "$CURR_BRANCH" --json number -q .number)
      PR_URL=$(gh pr view "$CURR_BRANCH" --json url -q .url)
      echo "üîó PR #$PR: $PR_URL"
      echo
      echo "=== üìä PR Diff (stat) ==="
      gh pr diff "$PR" --stat || true
      echo
      echo "=== üìÑ PR ge√§nderte Dateien ==="
      gh pr diff "$PR" --name-only || true
      echo

      # Helper: Anzahl der Suggested-Change-Kommentare z√§hlen
      count_suggestions() {
        gh api "repos/$(gh repo view --json owner -q .owner.login)/$(gh repo view --json name -q .name)/pulls/$PR/comments" --paginate \
          -q '[.[] | select(.user.login=="'"$BOT"'" and (.body|test("```suggestion")))] | length' 2>/dev/null || echo 0
      }

      # Sicherstellen dass das Apply-Script existiert
      mkdir -p scripts
      if [ ! -f scripts/apply_coderabbit_suggestions.js ]; then
        echo "‚ö†Ô∏è  Apply-Script fehlt. Bitte 'warp run create-coderabbit-script' ausf√ºhren."
        exit 1
      fi

      # 3) Poll ‚Üí Apply ‚Üí Commit ‚Üí Push (iterativ)
      echo "ü§ñ Warte auf CodeRabbit Suggestions..."
      total_applied=0
      elapsed=0
      iteration=1
      
      while [ "$elapsed" -lt "$TIMEOUT_SECONDS" ]; do
        # Warte auf Suggestions
        while [ "$elapsed" -lt "$TIMEOUT_SECONDS" ]; do
          cnt=$(count_suggestions)
          if [ "$cnt" -gt 0 ]; then 
            echo "‚úÖ $cnt Suggestion(s) gefunden in Iteration $iteration"
            break
          fi
          
          if [ "$((elapsed % 60))" -eq 0 ] && [ "$elapsed" -gt 0 ]; then
            echo "‚è≥ Warte auf CodeRabbit... (${elapsed}s/${TIMEOUT_SECONDS}s)"
          fi
          
          sleep "$POLL_SECONDS"
          elapsed=$((elapsed + POLL_SECONDS))
        done

        if [ "$elapsed" -ge "$TIMEOUT_SECONDS" ]; then
          echo "‚ö†Ô∏è  Timeout erreicht: keine Suggested Changes von $BOT."
          break
        fi

        # Apply suggestions
        echo "üîß Wende Suggestions an..."
        export PR BOT
        out=$(node scripts/apply_coderabbit_suggestions.js 2>&1 || echo "APPLIED_COUNT=0")
        echo "$out"
        applied=$(echo "$out" | grep -Eo 'APPLIED_COUNT=[0-9]+' | cut -d= -f2 || echo 0)
        total_applied=$((total_applied + applied))

        if [ "$applied" -gt 0 ] && ! git diff --quiet; then
          git add -A
          git commit -m "chore: apply CodeRabbit suggestions (iteration $iteration, $applied changes)"
          git push
          echo "üì§ Pushed $applied changes from iteration $iteration"
        fi

        sleep "$POLL_SECONDS"
        elapsed=$((elapsed + POLL_SECONDS))
        
        # Check for new suggestions
        next=$(count_suggestions)
        if [ "$next" -eq 0 ]; then
          echo "‚ÑπÔ∏è  Keine weiteren Suggestions vorhanden."
          break
        fi
        
        iteration=$((iteration + 1))
        echo "üîÑ Iteration $iteration startet..."
      done

      echo
      echo "‚Äî‚Äî üìã CodeRabbit Snapshot (letzte 3 Kommentare) ‚Äî‚Äî"
      gh api "repos/$(gh repo view --json owner -q .owner.login)/$(gh repo view --json name -q .name)/pulls/$PR/comments" --paginate \
        -q '[.[] | select(.user.login=="'"$BOT"'")] | .[-3:][] | "- " + (.path + ":" + ((.line//.original_line|tostring)) + " ¬∑ " + (.body|split("\n")[0]))' 2>/dev/null || echo "Keine Comments verf√ºgbar"
      echo "üßÆ Insgesamt angewendet: $total_applied Suggestions"
      echo "üîó PR: $PR_URL"
      echo

      # 4) Vercel Preview Deploy
      echo "üöÄ Deploying Vercel Preview..."
      if command -v vercel >/dev/null; then
        vercel --confirm || echo "‚ö†Ô∏è  Vercel deploy failed"
      else
        echo "‚ö†Ô∏è  Vercel CLI nicht installiert - √ºberspringe Preview Deploy"
      fi
      
      echo "‚úÖ Workflow abgeschlossen!"
    arguments:
      - name: base
        default: develop

  # Bonus: Nur die √Ñnderungen vs. BASE schnell ansehen (ohne Deploy)
  - name: show-diff-vs-base
    description: Zeigt Delta des aktuellen Branches gegen√ºber BASE (Dateien, Stat, letzte Commits)
    command: |
      set -euo pipefail
      BASE="{{base}}"
      [ -z "${BASE}" ] && BASE="develop"
      
      echo "üîÑ Fetching origin/$BASE..."
      git fetch origin "$BASE" || true
      echo
      echo "=== üìä √Ñnderungen gegen√ºber origin/$BASE (Dateien) ==="
      git --no-pager diff --name-status "origin/$BASE...HEAD" || true
      echo
      echo "=== üìà Diff-Statistik ==="
      git --no-pager diff --stat "origin/$BASE...HEAD" || true
      echo
      echo "=== üìù Commits gegen√ºber origin/$BASE ==="
      git --no-pager log --oneline --decorate --graph "origin/$BASE..HEAD" | head -20 || true
      echo
      echo "üåø Aktueller Branch: $(git rev-parse --abbrev-ref HEAD)"
      echo "üìç BASE: origin/$BASE"
    arguments:
      - name: base
        default: develop

  # Helper: CodeRabbit Apply-Script erstellen
  - name: create-coderabbit-script
    description: Erstellt das Node.js Script f√ºr CodeRabbit Suggestion Application
    command: |
      set -euo pipefail
      mkdir -p scripts
      
      cat > scripts/apply_coderabbit_suggestions.js << 'EOF'
      const { execSync } = require('child_process');
      const fs = require('fs');

      function sh(cmd) { 
        try {
          return execSync(cmd, { encoding: 'utf8' }); 
        } catch (error) {
          console.error(`Command failed: ${cmd}`);
          throw error;
        }
      }

      try {
        const repo = JSON.parse(sh('gh repo view --json owner,name'));
        const owner = repo.owner.login;
        const name  = repo.name;
        const pr    = process.env.PR;
        const bot   = process.env.BOT || 'coderabbitai[bot]';

        if (!pr) {
          console.error('PR environment variable not set');
          process.exit(1);
        }

        console.log(`Fetching suggestions from ${bot} for PR #${pr}...`);

        const comments = JSON.parse(sh(`gh api repos/${owner}/${name}/pulls/${pr}/comments --paginate`));

        const suggestions = comments
          .filter(c => c.user && c.user.login === bot)
          .map(c => {
            const match = c.body && c.body.match(/```suggestion\s*\n([\s\S]*?)```/m);
            if (!match) return null;
            
            const start = c.start_line || c.original_start_line || c.line || c.original_line;
            const end   = c.line || c.original_line || start;
            
            if (!c.path || !start || !end) {
              console.warn(`Skipping suggestion ${c.id}: missing path/line info`);
              return null;
            }
            
            return {
              path: c.path,
              start: Number(start),
              end: Number(end),
              text: match[1].replace(/\r/g, ''),
              id: c.id
            };
          })
          .filter(Boolean);

        if (!suggestions.length) {
          console.log('No suggestions found');
          console.log('APPLIED_COUNT=0');
          process.exit(0);
        }

        console.log(`Found ${suggestions.length} suggestions to apply`);

        // Dateiweise patchen, von unten nach oben (stabile Zeilen-Offsets)
        const byFile = {};
        for (const s of suggestions) {
          if (!byFile[s.path]) byFile[s.path] = [];
          byFile[s.path].push(s);
        }

        let applied = 0;
        for (const [path, fileSuggestions] of Object.entries(byFile)) {
          if (!fs.existsSync(path)) { 
            console.warn(`Skip missing file: ${path}`); 
            continue; 
          }
          
          console.log(`Applying ${fileSuggestions.length} suggestions to ${path}...`);
          
          const lines = fs.readFileSync(path, 'utf8').split('\n');
          
          // Sort by line number DESC (bottom to top) to maintain stable offsets
          fileSuggestions.sort((a, b) => (b.start - a.start) || (b.end - a.end));
          
          for (const s of fileSuggestions) {
            try {
              const startIdx = Math.max(1, s.start) - 1; // Convert to 0-based
              const endIdx = Math.max(1, s.end) - 1;
              
              const newLines = s.text.replace(/\n$/, '').split('\n');
              
              // Replace the range with new content
              lines.splice(startIdx, (endIdx - startIdx + 1), ...newLines);
              
              console.log(`‚úÖ Applied suggestion ${s.id} to ${path}:${s.start}-${s.end}`);
              applied++;
            } catch (error) {
              console.warn(`‚ùå Failed to apply suggestion ${s.id} to ${path}:${s.start}-${s.end} - ${error.message}`);
            }
          }
          
          // Write back the modified file
          fs.writeFileSync(path, lines.join('\n'), 'utf8');
        }
        
        console.log(`Successfully applied ${applied} suggestions`);
        console.log(`APPLIED_COUNT=${applied}`);
        
      } catch (error) {
        console.error(`Script error: ${error.message}`);
        console.log('APPLIED_COUNT=0');
        process.exit(1);
      }
      EOF

      echo "‚úÖ CodeRabbit apply script created at scripts/apply_coderabbit_suggestions.js"
      echo "üìù Make sure to run 'chmod +x scripts/apply_coderabbit_suggestions.js' if needed"

  # Quick CodeRabbit status check
  - name: check-coderabbit
    description: Zeigt aktuellen CodeRabbit Status f√ºr die aktuelle PR
    command: |
      set -euo pipefail
      
      CURR_BRANCH=$(git rev-parse --abbrev-ref HEAD)
      BOT="${BOT:-coderabbitai[bot]}"
      
      if ! gh pr view "$CURR_BRANCH" >/dev/null 2>&1; then
        echo "‚ùå Keine PR f√ºr Branch '$CURR_BRANCH' gefunden"
        exit 1
      fi
      
      PR=$(gh pr view "$CURR_BRANCH" --json number -q .number)
      PR_URL=$(gh pr view "$CURR_BRANCH" --json url -q .url)
      
      echo "üîó PR #$PR: $PR_URL"
      echo "üåø Branch: $CURR_BRANCH"
      echo
      
      # Count suggestions
      cnt=$(gh api "repos/$(gh repo view --json owner -q .owner.login)/$(gh repo view --json name -q .name)/pulls/$PR/comments" --paginate \
        -q '[.[] | select(.user.login=="'"$BOT"'" and (.body|test("```suggestion")))] | length' 2>/dev/null || echo 0)
      
      echo "ü§ñ CodeRabbit Suggestions: $cnt"
      echo
      echo "=== üí¨ Letzte CodeRabbit Kommentare ==="
      gh api "repos/$(gh repo view --json owner -q .owner.login)/$(gh repo view --json name -q .name)/pulls/$PR/comments" --paginate \
        -q '[.[] | select(.user.login=="'"$BOT"'")] | .[-3:][] | "üìù " + (.created_at|strftime("%H:%M")) + " - " + (.path // "general") + ": " + (.body|split("\n")[0]|.[0:80])' 2>/dev/null || echo "Keine Comments verf√ºgbar"
